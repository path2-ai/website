# Building heuristics

If you want to automate parts of your data labeling, heuristics like labeling functions come in handy. To do so, simply head over to the heuristics page and select "Labeling function" from the "New heuristic" button.

![](https://files.readme.io/01629e7-new_lf.png 'new lf.png')

## Writing your labeling function

You'll jump into a heuristic page with some code editor. Here you can write Python functions that take as input a dictionary (we loop over all records of your project, so imagine this to be one specific record - just as in the [record IDE](doc:manual-labeling-workflow#record-ide).), and output a label name.

![](https://files.readme.io/ac78c8f-Starts_with_Digit.png 'Starts with Digit.png')

We run this code as containerized functions, such that we need to prepare your execution environment. You can find installed libraries in the [requirements.txt](https://github.com/code-kern-ai/lf-execution-environment/blob/dev/requirements.txt) of our execution environment repository.

As with any other heuristic, your function will automatically and continuously be [evaluated](doc:evaluating-heuristics) against the data you label manually.

## Lookup lists for distant supervision

You'll quickly see that many of the functions you want to write are based on list expressions. But hey, you most certainly don't want to start maintaining a long list in your heuristic, right? That's why we've integrated automated lookup lists into our application.

As you manually label spans for your extraction tasks, we collect and store these values in a lookup list for the given label.

![](https://files.readme.io/017c1a8-labeling_entity.png 'labeling entity.png')

You can access them via the heuristic overview page when you click on "Lookup lists". You'll then find another overview page with the lookup lists.

![](https://files.readme.io/5d9d9a2-LL_Overview.png 'LL Overview.png')

If you click on "Details", you'll see the respective list and its terms. You can of course also create them fully manually, and add terms as you like. This is also helpful if you have a long list of regular expressions you want to check for your heuristics. You can also see the python variable name of the lookup list, as in this example `countries`.

![](https://files.readme.io/8e7144b-Lookup_List.png 'Lookup List.png')

In your labeling function, you can then import it from the module `knowledge`, where we store your lookup lists. In this example, it would look as follows:

![](https://files.readme.io/09690a9-Function_LL.png 'Function LL.png')

## Heuristics for extraction tasks

You might already wonder what labeling functions look like for extraction tasks, as labels are on token-level. Essentially, they differ in two characteristics:

- you use `yield` instead of `return`, as there can be multiple instances of a label in one text (e.g. multiple people)
- you specify not only the label name but also the start index and end index of the span.

An example that incorporates an existing knowledge base to find further examples of this label type looks as follows:

![](https://files.readme.io/c26cad0-gazetter.png 'gazetter.png')

This is also where the tokenization via `spaCy` comes in handy. You can access attributes such as `noun_chunks` from your attributes, which show you the very spans you want to label in many cases. Our [template functions repository](https://github.com/code-kern-ai/template-functions) contains some great examples of how to use that.

## Template functions

We realize that labeling functions can at first be a bit difficult to write. Because of that, we have a super simple [GitHub repository](https://github.com/code-kern-ai/template-functions) in which we show some exemplary usages. You can copy and paste them, and even use them fully outside of our application.

![](https://files.readme.io/fae543a-Template_LFs.png 'Template LFs.png')

If you have further ideas for template functions, please feel free to add them as [issues](https://github.com/code-kern-ai/template-functions/issues).

## Active learning for classification

Just as you can write [labeling functions](doc:building-labeling-functions) for your labeling automation, you can also easily integrate active learners. To do so, head to the heuristics overview page and select "Active learning" from the "New heuristic" button.

![](https://files.readme.io/bc0c7a1-new_al.png 'new al.png')

Similar to the labeling function editor, a coding interface will appear with pre-entered data. Once you made sure that you have the right labeling task selected, you can pick an embedding from the purple badges right above the editor. If you click on them, their configuration will be copied to your clipboard, such that you can enter the name into the value `embedding_name` of decorator `@params_fit`.

![](https://files.readme.io/97bd540-Bert_Classifier.png 'Bert Classifier.png')

You can use [Scikit-Learn](https://scikit-learn.org/stable/) inside the editor as you like, e.g. to extend your model with grid search. The `self.model` is any model that fits the [Scikit-Learn estimator interface](https://scikit-learn.org/stable/developers/develop.html), i.e. you can also write code like this:

```python
from sklearn.model_selection import GridSearchCV
from sklearn.tree import DecisionTreeClassifier

class ActiveDecisionTree(LearningClassifier):

    def __init__(self):
        params = {
            "criterion": ["gini", "entropy"],
            "max_depth": [5, 10, None]
        }
        self.model = GridSearchCV(DecisionTreeClassifier(), params, cv=3)

# ...
```

As with any other heuristic, your function will automatically and continuously be [evaluated](doc:evaluating-heuristics) against the data you label manually.

## Minimum confidence for finetuning

One way to improve the precision of your heuristics is to label more data (also, there typically is a steep learning curve, in the beginning, so make sure to label at least some records). Another way is to increase the `min_confidence` threshold of the `@params_inference` decorator. Generally, precision beats recall in active learners for weak supervision, so it is perfectly fine to choose higher values for the minimum confidence.

## Active learning for extraction

We're using our own library [sequencelearn](https://github.com/code-kern-ai/sequence-learn) to enable a Scikit-Learn-like API for programming span predictors, which you can also use [outside of our application](https://github.com/code-kern-ai/sequence-learn/blob/main/tutorials/Learning%20to%20predict%20named%20entities.ipynb).

Other than importing a different library, the logic works analog to active learning classifiers.

## Zero-shot

Zero-shot classifiers are amazing. Deriving predictions without labeling any data is great, but they are even better suitable as heuristics:

- Zero-shot (and few-shot) learning quickly hit plateaus in performance, such that more labeled data doesn't add value.
- They are highly reliant on the prompt they've been engineered on (for more details on this, take a look at our blog; we explain how zero-shot works there in greater detail).
- They are rather computationally expensive, such that they often are too slow for inference.

Again, they are amazing heuristics. So let's build a zero-shot classifier! To do so, we head over to the heuristics page and select "Zero-shot" from the "New heuristic" button.

![](https://files.readme.io/e9c5bee-new_zs.png 'new zs.png')

We now have to pick a target task, attribute, and configuration handle. We pull the zero-shot classifiers directly from [ðŸ¤— Hugging Face](https://huggingface.co/). You can either search for classifiers or pick one from our recommendations.

![](https://files.readme.io/7770c2c-new_zero-shot.png 'new zero-shot.png')

Once you've selected a zero-shot model, you enter into the details page. Other than [labeling functions](doc:building-labeling-functions) or [active learners](doc:building-active-learners), there is no editor to program into. Instead, you can only pick which labels should be predicted.

Also, as already mentioned, zero-shot classifiers are rather slow, so it makes perfect sense to first play a bit with sample records to estimate the performance. You can enter an arbitrary text into the playground, or compute the predictions for 10 randomly selected records from your data.

![](https://files.readme.io/55169ed-Zero-Shot.png 'Zero-Shot.png')

If you're happy with the model, you can click on the purple "Run" button, which will compute the results on all your records.

As with any other heuristic, your function will automatically and continuously be [evaluated](doc:evaluating-heuristics) against the data you label manually.

> ðŸš§ Zero-shot extractors are in active development
>
> Zero-shot classifiers are freshly integrated into our application. But we're already working on extractors and extensive prompt engineering, so stay tuned!

## Crowd labeling as a heuristic

When you have some annotation budget available, you can set up a crowd labeled heuristic. Imagine this to be a "heuristic executed by money" ;-)

![](https://files.readme.io/0b3d72d-crowd-labeler.png)

To execute such a heuristic, you need to have a [role](doc:managing-roles) set up as an annotator, and you need to specify a static data slice in the databrowser.

## Evaluating heuristics

We constantly analyze how well your heuristics are doing, no matter what type they are. Once you execute a heuristic - and there is some manually labeled data we can use for evaluation - you will find a statistic like this at the bottom of your heuristics page:

![](https://files.readme.io/a29ac42-statistics.png 'statistics.png')

It shows you per label the relevant data for you to know. The values have the following meaning:

- `est. precision` = `true positives / (true positives + false positives)` for the reference data you labeled.
- `est. recall` (only for extraction tasks) = `true positives / (true positives + false negatives)` for the reference data you labeled.
- `coverage`: how many records does this heuristic _generally_ hit?
- `hits` (only for extraction tasks): how many spans are hit by this heuristic?
- `conflicts`: on how many records (or spans) does this heuristic create conflicting expressions to other heuristics? (E.g. heuristic A says record 1 is "positive", while heuristic B says it is "negative").
- `overlaps`: on how many records (or spans) does this heuristic create overlapping expressions to other heuristics? (E.g. heuristic A says record 1 is "positive", and so does also heuristic B).

You can also find the precision and coverage for each heuristic on the heuristics overview page.

![](https://files.readme.io/5ca42e7-Heuristics_Overview.png 'Heuristics Overview.png')
